import { ElementCreator } from './elementCreator';
import { CallableInstance } from './internal/utils';
import { Cell, CodeCell, DisplayData, ErrorOutput, ExecuteResult, MarkdownCell, Notebook, Output, RawCell, StreamOutput } from './nbformat';
export declare type NbRendererOpts<TElement = HTMLElement> = {
    /**
     * An object with additional data renderers indexed by a media type.
     */
    dataRenderers?: DataRenderers<TElement>;
    /**
     * An array of the supported MIME types in the priority order. When a cell
     * contains multiple representations of the data, the one with the media type
     * that has the lowest index in this array will be rendered. The default is
     * `Object.keys({ ...dataRenderers, ...builtinRenderers })`.
     */
    dataTypesPriority?: string[];
    /**
     * A function for converting ANSI escape sequences in the given *text* to HTML.
     * It gets the text from the cell as-is, without prior escaping, so it must
     * escape special characters unsafe for HTML (ansi_up does it implicitly)!
     */
    ansiCodesRenderer?: (text: string) => string;
    /**
     * A function for highlighting the given source *code*, it should return an
     * HTML string. It gets the text from the cell as-is, without prior escaping,
     * so it must escape special characters unsafe for HTML (highlight.js does it
     * implicitly)!
     */
    codeHighlighter?: (code: string, lang: string) => string;
    /**
     * A function for converting the given Markdown source to HTML.
     */
    markdownRenderer?: (markup: string) => string;
};
export declare type DataRenderer<TElement = HTMLElement> = (this: NbRenderer<TElement> | void, data: string) => TElement;
declare type DataRenderers<TElement> = {
    [mediaType: string]: DataRenderer<TElement>;
};
declare class NbRenderer<TElement> extends CallableInstance<NbRenderer<TElement>> {
    readonly el: ElementCreator<TElement>;
    readonly renderMarkdown: NonNullable<NbRendererOpts['markdownRenderer']>;
    readonly renderAnsiCodes: NonNullable<NbRendererOpts['ansiCodesRenderer']>;
    readonly highlightCode: NonNullable<NbRendererOpts['codeHighlighter']>;
    readonly dataRenderers: DataRenderers<TElement>;
    readonly dataTypesPriority: string[];
    /**
     * Creates a Notebook renderer with the given options. The constructed object
     * is "callable", i.e. you can treat it as a function.
     *
     * @example
     *   const renderer = new NbRenderer(document.createElement.bind(document))
     *   console.log(renderer(notebook).outerHTML)
     *
     * @param {ElementCreator} elementCreator The function that will be used for
     *   building all HTML elements.
     * @param {NbRendererOpts} opts The renderer's options.
     */
    constructor(elementCreator: ElementCreator<TElement>, opts?: NbRendererOpts<TElement>);
    /**
     * Renders the given Jupyter *notebook*.
     */
    __call__(notebook: Notebook): TElement;
    /**
     * Renders the given Jupyter *notebook*.
     */
    render(notebook: Notebook): TElement;
    renderCell(cell: Cell, notebook: Notebook): TElement;
    renderMarkdownCell(cell: MarkdownCell, _notebook: Notebook): TElement;
    renderRawCell(cell: RawCell, _notebook: Notebook): TElement;
    renderCodeCell(cell: CodeCell, notebook: Notebook): TElement;
    renderSource(cell: CodeCell, notebook: Notebook): TElement;
    renderOutput(output: Output, cell: CodeCell): TElement;
    renderDisplayData(output: DisplayData): TElement;
    renderExecuteResult(output: ExecuteResult): TElement;
    renderError(error: ErrorOutput): TElement;
    renderStream(stream: StreamOutput): TElement;
    renderData(mimeType: string, data: string): TElement;
    resolveDataType(output: DisplayData | ExecuteResult): string | undefined;
}
export default NbRenderer;
//# sourceMappingURL=renderer.d.ts.map