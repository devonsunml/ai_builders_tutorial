"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./internal/utils");
const nbformat_1 = require("./nbformat");
function joinText(text) {
    return Array.isArray(text) ? text.map(joinText).join('') : text;
}
function coalesceStreams(outputs) {
    if (!outputs.length) {
        return outputs;
    }
    let last = outputs[0];
    const newOutputs = [last];
    for (const output of outputs.slice(1)) {
        if (output.output_type === 'stream' && last.output_type === 'stream' && output.name === last.name) {
            last.text = last.text.concat(...output.text);
        }
        else {
            newOutputs.push(output);
            last = output;
        }
    }
    return newOutputs;
}
function executionCountAttrs({ execution_count: count }) {
    return count ? {
        'data-execution-count': String(count),
        // Only for backward compatibility with notebook.js.
        'data-prompt-number': String(count),
    } : {};
}
function notebookLanguage({ metadata: meta }) {
    var _a, _b;
    return (_b = (_a = meta.language_info) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'python';
}
class NbRenderer extends utils_1.CallableInstance {
    /**
     * Creates a Notebook renderer with the given options. The constructed object
     * is "callable", i.e. you can treat it as a function.
     *
     * @example
     *   const renderer = new NbRenderer(document.createElement.bind(document))
     *   console.log(renderer(notebook).outerHTML)
     *
     * @param {ElementCreator} elementCreator The function that will be used for
     *   building all HTML elements.
     * @param {NbRendererOpts} opts The renderer's options.
     */
    constructor(elementCreator, opts = {}) {
        var _a, _b, _c, _d;
        super();
        this.el = elementCreator;
        this.renderMarkdown = (_a = opts.markdownRenderer) !== null && _a !== void 0 ? _a : utils_1.identity;
        this.renderAnsiCodes = (_b = opts.ansiCodesRenderer) !== null && _b !== void 0 ? _b : utils_1.escapeHTML;
        this.highlightCode = (_c = opts.codeHighlighter) !== null && _c !== void 0 ? _c : utils_1.escapeHTML;
        const el2 = (tag, classes) => (data) => this.el(tag, classes, data);
        const embeddedImageEl = (format) => (data) => this.el('img', {
            class: 'image-output',
            src: `data:image/${format};base64,${data.replace(/\n/g, '')}`,
        });
        // opts.dataRenderers is intentionally included twice; to get the user's
        // provided renderers in the default dataTypesPriority before the built-in
        // renderers and at the same time allow to override any built-in renderer.
        this.dataRenderers = {
            ...opts.dataRenderers,
            'image/png': embeddedImageEl('png'),
            'image/jpeg': embeddedImageEl('jpeg'),
            'image/svg+xml': el2('div', ['svg-output']),
            'text/svg+xml': (data) => this.dataRenderers['image/svg+xml'].call(this, data),
            'text/html': el2('div', ['html-output']),
            'text/markdown': (data) => this.el('div', ['html-output'], this.renderMarkdown(data)),
            'text/latex': el2('div', ['latex-output']),
            'application/javascript': el2('script', []),
            'text/plain': (data) => this.el('pre', ['text-output'], utils_1.escapeHTML(data)),
            ...opts.dataRenderers,
        };
        this.dataTypesPriority = (_d = opts.dataTypesPriority) !== null && _d !== void 0 ? _d : Object.keys(this.dataRenderers);
    }
    /**
     * Renders the given Jupyter *notebook*.
     */
    __call__(notebook) {
        return this.render(notebook);
    }
    /**
     * Renders the given Jupyter *notebook*.
     */
    render(notebook) {
        const children = notebook.cells.map(cell => this.renderCell(cell, notebook));
        return this.el('div', ['notebook'], children);
    }
    renderCell(cell, notebook) {
        switch (cell.cell_type) {
            case nbformat_1.CellType.Code: return this.renderCodeCell(cell, notebook);
            case nbformat_1.CellType.Markdown: return this.renderMarkdownCell(cell, notebook);
            case nbformat_1.CellType.Raw: return this.renderRawCell(cell, notebook);
            default: return this.el('div', [], '<!-- Unsupported cell type -->');
        }
    }
    renderMarkdownCell(cell, _notebook) {
        return this.el('section', ['cell', 'markdown-cell'], this.renderMarkdown(joinText(cell.source)));
    }
    renderRawCell(cell, _notebook) {
        return this.el('section', ['cell', 'raw-cell'], joinText(cell.source));
    }
    renderCodeCell(cell, notebook) {
        var _a;
        const source = cell.source.length > 0
            ? this.renderSource(cell, notebook)
            : this.el('div');
        const outputs = coalesceStreams((_a = cell.outputs) !== null && _a !== void 0 ? _a : [])
            .map(output => this.renderOutput(output, cell));
        return this.el('section', ['cell', 'code-cell'], [source, ...outputs]);
    }
    renderSource(cell, notebook) {
        const lang = notebookLanguage(notebook);
        const html = this.highlightCode(joinText(cell.source), lang);
        const codeEl = this.el('code', { 'class': `lang-${lang}`, 'data-language': lang }, html);
        const preEl = this.el('pre', [], [codeEl]);
        // Class "input" is for backward compatibility with notebook.js.
        const attrs = { ...executionCountAttrs(cell), class: 'source input' };
        return this.el('div', attrs, [preEl]);
    }
    renderOutput(output, cell) {
        const innerEl = (() => {
            switch (output.output_type) {
                case nbformat_1.OutputType.DisplayData: return this.renderDisplayData(output);
                case nbformat_1.OutputType.ExecuteResult: return this.renderExecuteResult(output);
                case nbformat_1.OutputType.Stream: return this.renderStream(output);
                case nbformat_1.OutputType.Error: return this.renderError(output);
                default: return this.el('div', [], '<!-- Unsupported output type -->');
            }
        })();
        const attrs = { ...executionCountAttrs(cell), class: 'output' };
        return this.el('div', attrs, [innerEl]);
    }
    renderDisplayData(output) {
        const type = this.resolveDataType(output);
        if (type) {
            return this.renderData(type, joinText(output.data[type]));
        }
        return this.el('div', ['empty-output']);
    }
    renderExecuteResult(output) {
        const type = this.resolveDataType(output);
        if (type) {
            return this.renderData(type, joinText(output.data[type]));
        }
        return this.el('div', ['empty-output']);
    }
    renderError(error) {
        const html = this.renderAnsiCodes(error.traceback.join('\n'));
        // Class "pyerr" is for backward compatibility with notebook.js.
        return this.el('pre', ['error', 'pyerr'], html);
    }
    renderStream(stream) {
        const html = this.renderAnsiCodes(joinText(stream.text));
        return this.el('pre', [stream.name], html);
    }
    renderData(mimeType, data) {
        const render = this.dataRenderers[mimeType];
        if (!render) {
            throw RangeError(`missing renderer for MIME type: ${mimeType}`);
        }
        return render.call(this, data);
    }
    resolveDataType(output) {
        return this.dataTypesPriority.find(type => output.data[type]);
    }
}
exports.default = NbRenderer;
//# sourceMappingURL=renderer.js.map